\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{pgf}
\usepackage{verbatim}
\usepackage{inconsolata}
\usepackage{listings}
\lstset{language=C, frame=single,
  basicstyle=\scriptsize\ttfamily,
  numbers=left, numberstyle=\tiny\color{gray},
   numbersep=5pt, fancyvrb=true
}

\usefonttheme{professionalfonts} % using non standard fonts for beamer
\usefonttheme{serif} % default family is serif
% \usepackage{fontspec}
% \setmainfont{Palatino}

\usepackage{pgf}
\usepackage{tikz}
\usepackage{graphicx}
\usetikzlibrary{%
  arrows,
  arrows.meta,
  positioning,
  calc,
  backgrounds,
  chains,
  matrix,
  patterns,
  automata,
  fit,
  graphs,
  decorations,
  decorations.pathmorphing,
  decorations.pathreplacing,
  decorations.markings,
}

\usepgflibrary{shapes,shapes.geometric}


\usepackage{url}
\usepackage{xmpmulti}
% \usepackage{euler}
\usepackage[T1]{fontenc}
\pdfpagebox5
\immediate\write18{sh ./vc}
\input{vc}

\author{Gianluca Della Vedova}
\title{Elementi di Bioinformatica}
\institute{Univ. Milano--Bicocca\\
  \texttt{http://gianluca.dellavedova.org}}
\date{\today, {\tiny revisione \VCRevision}}
%\pgfdeclareimage[height=1cm]{university-logo}{logounimib}
%\logo{\pgfuseimage{university-logo}}



% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command:
\beamerdefaultoverlayspecification{<+->}

\graphicspath{{figures/}}


\begin{document}
\begin{frame}
  \titlepage
\end{frame}


\begin{frame}\frametitle{Gianluca Della Vedova}
\begin{itemize}
\item
Elementi di Bioinformatica
\item
Ufficio U14-2041
\item
\url{https://gianluca.dellavedova.org}
\item
\url{https://elearning.unimib.it/course/view.php?id=15423}
\item
\url{gianluca.dellavedova@unimib.it}
\item\url{https://github.com/bioinformatica-corso/programmi-elementi-bioinformatica}
\item\url{https://github.com/bioinformatica-corso/lezioni}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Notazione}
\begin{itemize}
\item
\alert{simbolo}: $T[i]$\\
\item
\alert{stringa}: $T[1]T[2]\cdots T[l]$\\
\item
\alert{sottostringa}: $T[i:j]$\\
\item
\alert{prefisso}: $T[:j]=T[1:j]$\\
\item
\alert{suffisso}: $T[i:]=T[i:|T|]$
\item
\alert{concatenazione}: $T_{1}\cdot T_{2} = T_{1}T_{2}$
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Pattern Matching}
\begin{block}{Problema}
\alert{Input}: testo $T=T[1]\cdots T[n]$, pattern $P=P[1]\cdots P[m]$, alfabeto $\Sigma$\\
\alert{Goal}: trovare \emph{tutte} le occorrenze di $P$ in $T$\\
\alert{Goal}: trovare tutti gli $i$ tale che $T[i]\cdots T[i+m-1]=P$
\end{block}
\begin{block}{Algoritmo banale}
\alert{Tempo}: $O(nm)$
\end{block}
\begin{block}{Lower bound}
\alert{Tempo}: $O(n+m)$
\end{block}
\end{frame}

\begin{frame}
\frametitle{Bit-parallel}
\begin{block}{Algoritmi seminumerici}
\begin{itemize}
\item
$25$
\item
$25=00011001$
\item
$25=00011001=$FFFTTFFT
\end{itemize}
\end{block}
\begin{block}{Operazioni bit-level}
\alert{Or}: $x\lor y$, \alert{And}: $x\land y$, \alert{Xor}: $x\oplus y$\\
\alert{Left Shift}: $x << k$, \alert{Right Shift}: $x >> k$,
\begin{itemize}
\item
Tutte bitwise
\item
Tutte in hardware
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{D\"om\"olki / Baeza-Yates, Gonnet}
\begin{block}{Matrice $M$}
$M(i,j)=1$ sse $P[:i]=T[j-i+1:j]$\\
$0\le i\le m$, $0\le j\le n$
\end{block}
\begin{block}{Occorrenza di $P$ in $T$}
$M(m,\cdot)=1$
\end{block}
\begin{itemize}
\item
$M(0,\cdot)=1$, $M(\cdot,0)=0$
\item
\alert{$M(i,j)=1$} sse $M(i-1, j-1)=1$ AND $P[i]=T[j]$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Esempio}
\begin{block}{Esempio}
$T$=abracadabra\\
$P$=abr
\end{block}

\begin{center}
\begin{tabular}[l]{ll}
%\hline{1}
10010101001\\
01000000100\\
00100000010&$\leftarrow$ \alert{occorrenze}\\%\hline
\end{tabular}
\end{center}

\begin{block}{Matrice $M$}
1 colonna = 1 numero
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Colonne}
$U[\sigma]$ = array di bit dove $U[\sigma,i]=1$ sse $P[i]=\sigma$

\begin{block}{$C[j]$ da $C[j-1]$}
\begin{itemize}
\item
Right shift di $C[j-1]$
\item
$1$ in prima posizione
\item
AND con $U[T[j]]$
\item
\alert{$\omega$}: word size
\item
$C[j] = \left( \left(C[j-1] >> 1 \right) \  | \  \left(1 << (\omega -1) \right) \right)\ \&\  U[T[j]]$;
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Note}
\begin{itemize}
\item
Tempo $O(n)$ se $m\le \omega$
\item
Tempo $O(nm)$
\item
No condizioni
\item
$\omega < m\le 2\omega$?
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Karp-Rabin}
\begin{block}{Alfabeto binario}
\begin{itemize}
\item
$H(S)=\sum_{i=1}^{|S|} 2^{|S| - i}H(S[i])$
\item
sliding window di ampiezza $m$ su $T$
\item
$H(T[i+1:i+m]) =$\\
$=\left(H(T[i:i+m-1]) - T[i] \right) / 2 + 2^{m-1}T[i+m]$
\item
operazioni su bit
\item
$T[i:i+m-1]=P \Leftrightarrow H(T[i:i+m-1])=H(P)$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Karp-Rabin: problema}
\begin{block}{Numeri troppo grandi}
\begin{itemize}
\item
Modello RAM: numeri $O(n+m)$
\item
mod $p$
\item
$H(T[i+1:i+m]) =$\\
$\left(\left(H(T[i:i+m-1]) - T[i] \right) / 2 + 2^{m-1}T[i+m] \right)\mod p$
\item \textbf{NO}
\item
$2^{m-1}T[i+m] \mod p$ calcolato iterativamente, $\mod p$ ad ogni passo
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Karp-Rabin: falsi positivi}
\begin{block}{Possibili errori}
\begin{itemize}
\item
Falso positivo (FP): occorrenza non vera
\item
Falso negativo (FN): occorrenza non trovata
\item
$H(T[i:i+m-1])=H(P) \Leftrightarrow T[i:i+m-1]=P$
\item
$H(T[i:i+m-1])  \mod p = H(P)  \mod p$
$\Leftarrow T[i:i+m-1]=P$
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Karp-Rabin: falsi positivi}
\begin{block}{Probabilità di errore}
$P[\#FP\ge 1] \le O(nm/I)$ se il numero primo $p$ è scelto fra tutti i primi $\le
I$
\end{block}

\begin{block}{Valori di $I$}
\begin{itemize}
\item
$I=n^{2}m \Rightarrow P[\#FP\ge 1] \le 2.54/n$
\item
$I=nm^{2}  \Rightarrow P[\#FP\ge 1] \in O(1/m)$
\end{itemize}
\end{block}

\begin{block}{Abbassare probabilità di errore}
Scegliere $k$ primi casuali (indipendenti senza ripetizioni), cambiare primo
dopo ogni FP
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Las Vegas vs.
  Monte Carlo}
\begin{block}{Classificazione algoritmi probabilistici}
\begin{itemize}
\item
Las Vegas:
\begin{itemize}
\item
Sempre corretto
\item
Forse non veloce
\item
Quicksort con pivot random
\end{itemize}
\item
Monte Carlo:
\begin{itemize}
\item
Sempre veloce

\item
Forse non corretto
\item
Karp-Rabin
\end{itemize}
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Controllo falsi positivi}
$L$: posizioni iniziali in $T$ delle occorrenze
\begin{block}{Run}
sequenza $\langle l_{1}, \ldots, l_{k}\rangle$ di posizioni in $L$ distanti al
massimo $m/2$
\end{block}

\begin{itemize}
\item
$d=l_{2}-l_{1}$
\item
$P$ semiperiodico con periodo $d$
\item
$P=\alpha\beta^{k-1}$, $\alpha$ suffisso di $\beta$
\item
ogni run occupa $\ge n$ caratteri di $T$
\item
ogni carattere  di $T$ è in max $2$ run
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Trie}
\begin{columns}
\begin{column}{0.6\textwidth}
\begin{block}{Trie}
\begin{itemize}
\item
Albero
\item
Query: parola $\in$ dizionario
\item
archi etichettati
\item
Percorso radice-foglia = parola
\end{itemize}
\end{block}
\begin{block}{Dizionario}
ABRACADABRA\\
ARRAY\\
\uncover<3->{\alert{ABRA}}
\end{block}
\end{column}
\begin{column}{0.4\textwidth}
\begin{center}
\onslide<2-3>{\includegraphics[width=\textwidth]{trie1}}
%\onslide<4->{\includegraphics[width=\textwidth]{trie3}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Trie}
\begin{columns}
\begin{column}{0.6\textwidth}
\begin{block}{Terminatore}
\$ non appartiene all'alfabeto
\end{block}
\onslide<2->{\begin{block}{Dizionario}
ABRACADABRA\$\\
ARRAY\$\\
ABRA\$
\end{block}}
\end{column}
\begin{column}{0.4\textwidth}
\begin{center}
\onslide<3->{\includegraphics[width=\textwidth]{trie4}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Suffix tree}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{block}{Definizione}
\begin{itemize}[<+->]
% \item
% Testo $T$
\item
Trie compatto di tutti i suffissi di $T\$$
\item
Le etichette degli archi uscenti da $x$ iniziano con simboli diversi
\item
suffissi $\Leftrightarrow$ percorso radice-foglia
\end{itemize}
\end{block}
\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
\uncover<4->{\includegraphics[width=\textwidth]{Suffix_tree_BANANA}

BANANA\$}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Suffix tree 2: Definizione}
\begin{itemize}
\item
foglie etichettata con posizione inizio suffisso
\item
path-label$(x)$: concatenazione etichette
\item
string-depth$(x)$: lunghezza path-label$(x)$
\item
Pattern matching = visita
\end{itemize}
\begin{block}{Problemi}
\begin{itemize}[<+->]
\item
Spazio $O(n^{2})$
\item
Puntatori al testo (posizioni)
\item
Spazio $20n$ bytes
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Suffix array}
\begin{block}{Definizione}
\begin{itemize}[<+->]
\item
Array dei suffissi in ordine lessicografico
\item
Posizioni iniziali del suffisso nell'array
\item
Spazio $4n$ bytes
\item
$Lcp[i]$: lunghezza prefisso comune $SA[i]$, $SA[i+1]$
\end{itemize}
\end{block}
\uncover<5->{\begin{block}{BANANA\$}
\begin{tabular}[l]{|c|l|l|l|l|l|l|l|}
\hline
$i$&0&1&2&3&4&5&6\\
$SA$&7&6&4&2&1&5&3\\
$Lcp$&0&1&3&0&0&2&-\\\hline
\end{tabular}}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Da Suffix tree a Suffix array}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{itemize}[<+->]
\item
Visita depth-first di $ST$
\item
archi uscenti di ogni nodo in ordine lessicografico
\item
$Lcp[i]$ = string-depth di $lca(i,i+1)$
\end{itemize}
\end{column}
\begin{column}{0.4\textwidth}
\begin{center}
\onslide<1->{\includegraphics[width=\textwidth]{Suffix_tree_BANANA}}
%\onslide<4->{\includegraphics[width=\textwidth]{trie3}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Da Suffix array a Suffix tree}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{itemize}[<+->]
\item
$Lcp = 0$:  partizione $SA$
\item
corrispondono ai figli della radice
\item
ricorsione prendendo i numeri minimi
\end{itemize}
\begin{block}{BANANA\$}
\begin{tabular}[l]{|c|l|l|l|l|l|l|l|}
\hline
$i$&0&1&2&3&4&5&6\\
$SA$&7&6&4&2&1&5&3\\
$Lcp$&0&1&3&0&0&2&-\\\hline
\end{tabular}
\end{block}
\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
\only<2>{\includegraphics[width=\textwidth]{Suffix_tree_BANANA-level1}}
\only<3>{\includegraphics[width=\textwidth]{Suffix_tree_BANANA-level2}}
\only<4>{\includegraphics[width=\textwidth]{Suffix_tree_BANANA-level3}}
\only<5>{\includegraphics[width=\textwidth]{Suffix_tree_BANANA}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sottostringa comune più lunga di due stringhe}
\begin{block}{Due stringhe $s_{1}$ e $s_{2}$}
\begin{itemize}[<+->]
\item
Suffix tree generalizzato = insieme di stringhe
\item
$ST(s_{1}\$_{1}s_{2}\$_{2})$
\item
Nodo $x$ con foglie di $s_{1}$ e $s_{2}$
\item
Sottostringa di $s_{1}$ e $s_{2}$
\item
$ST(s_{1}\$s_{2}\$)$
\item
Max string-depth
\end{itemize}
\end{block}
\end{frame}



\begin{frame}
\frametitle{Suffix tree generalizzato}
\begin{center}
\includegraphics[width=0.8\textwidth]{ST-banana-panna}
\end{center}
$s_{1}$: BANANA\$, $s_{2}$: PANNA\$
\end{frame}


\begin{frame}[fragile]
\frametitle{Pattern matching su suffix array}
\begin{block}{Occorrenza $P$ in $T$}
Suffissi di $T$ che iniziano con $P$
\end{block}
\begin{block}{Ricerca in $SA$}
\begin{itemize}
\item
Ricerca dicotomica
\item
Tempo $O(m \log n)$ -- caso pessimo
\item
Controllare tutto $P$ ad ogni iterazione
\item
$log_{2} n$ iterazioni
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Acceleranti 1}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{itemize}
\item
Intervallo $SA(L, R)$ di $SA$
\item
Elemento mediano $M$
\item
Tutti i suffissi in $SA(L,R)$ iniziano con uno stesso prefisso lungo $Lcp(SA[L],
SA[R])$
\item
Non confrontare con i primi $Lcp(SA[L], SA[R])$ caratteri
\end{itemize}
\end{column}
\begin{column}{0.4\textwidth}
\begin{center}
\onslide<1->{\multiinclude[<+>][start=1,format=pdf,graphics={width=0.95\textwidth}]{figures/SA-pattern-matching1}}
%\onslide<4->{\includegraphics[width=\textwidth]{trie3}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Acceleranti 2}
\begin{columns}[T]
\begin{column}[T]{0.6\textwidth}
\begin{block}{$l$: $lcp(L,P)$; $r$: $Lcp(R,P)$}
\begin{enumerate}
\item
Caso 1: $l>r$
\only<3->{\begin{itemize}\item
$Lcp(L,M)>l$\only<4->{$\Rightarrow L\gets M$}
\only<5->{\item
$Lcp(L,M)<l$\only<6->{$\Rightarrow$\\ $R\gets M, r\gets Lcp(M,L)$}}
\only<7->{\item
  $Lcp(L,M)=l$\only<8->{$\Rightarrow$ confronto $P[l+1:]$, $M[l+1:]$}
}\end{itemize}}
\only<9->{\item
  Caso 2: $l=r$
\only<10->{\begin{itemize}\item
  $Lcp(L,M)>l$
\only<11->{\item $Lcp(M,R)>l$}
\only<12->{\item $Lcp(L,M)=Lcp(M,R)=l$}
  \end{itemize}}}
\end{enumerate}
\end{block}
\end{column}
\begin{column}{0.38\textwidth}
\only<2->{\multiinclude[<+>][start=1,format=pdf,graphics={width=0.95\textwidth}]{figures/SA-accelerant}}
%\only<2->{\multiinclude[<alert@+| +->][start=1,format=pdf,graphics={width=0.95\textwidth}]{figures/SA-accelerant}}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Acceleranti 2: calcolo $Lcp$ in tempo $O(n)$}
\begin{itemize}[<+->]
\item
Iterazione 1: $(L,R)=(1,m)$
\item
Iterazione 2: $(L,R)=(1,m/2)$ oppure $(m/2,m)$
\item
Iterazione $k$: $L = h\frac{m}{2^{k-1}}$, $R = (h+1)\frac{m}{2^{k-1}}$
\item
Iterazione $\lceil \log_{2}m\rceil$: $R=L+1$, $Lcp(h,h+1)$
\item
Iterazione $\lceil \log_{2}m\rceil -1$: aggrego i risultati dell'iterazione
$\lceil \log_{2}m\rceil$
\item
Iterazione $k$: $Lcp(h\frac{m}{2^{k-1}}, (h+1)\frac{m}{2^{k-1}})$
\item
$=\min\{Lcp(2h\frac{m}{2^{k}}, (2h+1)\frac{m}{2^{k}})$,
$Lcp((2h+1)\frac{m}{2^{k}}+1, (2h+2)\frac{m}{2^{k}})$,
$Lcp((2h+1)\frac{m}{2^{k}}), Lcp((2h+1)\frac{m}{2^{k}}+1)\}$
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Acceleranti 2: calcolo $Lcp$ in tempo $O(n)$}
\multiinclude[<+>][start=1,format=pdf,graphics={width=0.95\textwidth}]{figures/SA-linear-Lcp}
\uncover<5->{Passaggio da $y$ a $z$ deve esistere}
\end{frame}

\begin{frame}
\frametitle{Acceleranti 2: Osservazione}
\begin{itemize}[<+->]
\item
Tempo per trovare un'occorrenza
\item
Tempo per trovare tutte le occorrenze?
\item
$O(n+m+k)$, per $k$ occorrenze
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Costruzione suffix array: nuovo alfabeto}
\begin{itemize}
\item
Alfabeto $\Sigma$ con $\sigma$ simboli, testo $T$ lungo $n$
\item
Aggrego triple di caratteri
\item
Alfabeto $\Sigma^{3}$ con $\sigma^{3}$ simboli, testo lungo $n/3$
\item
$T_{1}=(T[1],T[2],T[3])\cdots (T[3i+1],T[3i+2],T[3i+3])\cdots$\\
$T_{2}=(T[2],T[3],T[4])\cdots (T[3i+2],T[3i+3],T[3i+4])\cdots$\\
$T_{0}=(T[3],T[4],T[5])\cdots (T[3i],T[3i+1],T[3i+2])\cdots$
\item
suffissi$(T)$ $\Leftrightarrow$ $\bigcup_{i=0,1,2}$ suffissi$(T_{i})$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Costruzione suffix array: ricorsione}
\begin{enumerate}
\item
Ricorsione su $T_{0}T_{1}$
\item
suffissi$(T_{0}T_{1})$ $\Leftrightarrow$ suffissi$(T_{0})$, suffissi$(T_{1})$
\item
suffissi$(T_{0}T_{1})$  $\Leftrightarrow$ suffissi$(T_{2})$
\item
$T_{2}[i:] \approx T[3i+2:]$
\item
$T[3i+2:] = T[3i+2]T[3i+3:] =T[3i+2]T_{0}[i+1:]$
\item
suffissi$(T_{0})$ ordinati
\item
Radix sort
\item
Fusione suffissi$(T_{0}T_{1})$,  suffissi$(T_{2})$
\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{Costruzione suffix array: fusione}
Confronto suffisso di $T_{0}$ e $T_{2}$
\begin{enumerate}
\item
$T_{0}[i:] <=> T_{2}[j:]$
\item
$T[3i:] <=> T[3j+2:]$
\item
$T[3i]T[3i+1:] <=> T[3j+2]T[3j+3:]$
\item
$T[3i]T_{1}[i:] <=> T[3j+2]T_{0}[j+1:]$
\end{enumerate}
\end{frame}



\begin{frame}
\frametitle{Costruzione suffix array: fusione}
Confronto suffisso di $T_{1}$ e $T_{2}$
\begin{enumerate}
\item
$T_{1}[i:] <=> T_{2}[j:]$
\item
$T[3i+1:] <=> T[3j+2:]$
\item
$T[3i+1]T[3i+2:] <=> T[3j+2]T[3j+3:]$
\item
$T[3i+1]T[3i+2]T[3i+3:] <=> T[3j+2]T[3j+3]T[3j+4:]$
\item
$T[3i+1]T[3i+2]T_{0}[i+1:] <=> T[3j+2]T[3j+3]T_{1}[j+1:]$
\end{enumerate}
\end{frame}

\begin{frame}
\frametitle{KS}
\begin{enumerate}
\item
Juha Kärkkäinen, Peter Sanders and Stefan Burkhardt.
Linear work suffix array construction. J. ACM, 53 (6), 2006, pp. 918-936.
\item
Difference cover (DC) 3
\item
Stefan Burkhardt and Juha Kärkkäinen.
Fast lightweight suffix array construction and checking
In Proc. 14th Symposium on Combinatorial Pattern Matching (CPM '03), LNCS 2676,
Springer, 2003, pp. 55-69. \url{http://www.stefan-burkhardt.net/CODE/cpm_03.tar.gz}
\item
Yuta Mori.
SAIS \url{https://sites.google.com/site/yuta256/}
\end{enumerate}
\end{frame}


\begin{frame}[fragile]
\frametitle{Sottostringa comune più lunga}
\begin{block}{$k$ stringhe $\{s_{1}, \ldots , s_{k}\}$}
\begin{enumerate}[<+->]
\item
Suffix tree generalizzato
\item
Vettore $C_{x}[1:k]$ per ogni nodo $x$
\item
$C_{x}[i]$: sottoalbero con radice $x$ ha una foglia di $s_{i}$
\item
$C_{x} = \bigvee C$ sui figli di $C$
\item
Nodo $z$, $C_{z}=$ tutti ${1}$
\item
Tempo $O(kn)$
\item
$n$: summa lunghezze $|s_{1}| + \cdots + |s_{k}|$
\end{enumerate}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Lowest common ancestor (lca)}
\begin{block}{Dati albero $T$ e 2 foglie $x$, $y$}
\begin{itemize}
\item
$z$ è antenato comune di $x$, $y$ se
$z$ è antenato di entrambi $x$ e $y$
\item
$z$ è lca di $x$, $y$ se:
\begin{enumerate}
\item
$z$ è antenato comune di $x$ e $y$
\item
nessun discendente di $z$ è antenato comune di $x$ e $y$
\end{enumerate}
\end{itemize}
\end{block}
\begin{block}{Proprietà}
\begin{itemize}
\item
Preprocessing di $T$ in tempo $O(n)$
\item
Calcolo lca$(x,y)$ in tempo $O(1)$
\item
Algoritmo complesso, ma pratico
\end{itemize}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Sottostringa comune più lunga di $k$ stringhe}
\begin{block}{Arricchimento $ST$}
\begin{enumerate}[<+->]
\item
$N_{x}[i]$: numero foglie di $s_{i}$ discendenti di $x$
\item
$N_{x}[i]=0$ o $1$ per ogni foglia
\item
$N_{x}[i]=$ somma dei figli
\item
$D_{x}[i]$: numero di consecutive di foglie di $s_{i}$, ordinate secondo visita depth-first, discendenti di $x$
\item
$N_{x}[i]=0 \Rightarrow D_{x}[i]=0$
\item
$N_{x}[i]=1 \Rightarrow D_{x}[i]=0$
\item
$N_{x}[i]\ge 1 \Rightarrow D_{x}[i]=N_{x}[i]-1$
\item
$N_{x}[i] - D_{x}[i] =$ \uncover<2->{$C_{x}[i]$}
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sottostringa comune più lunga di $k$ stringhe}
\begin{block}{Gestione $ST$}
\begin{itemize}
\item
Visita depth-first di $ST$
\item
$L_{i}$: lista ordinata delle foglie di $s_{i}$
\item
Per ogni coppia $x,y$ consecutiva in $L_{i}$
\begin{enumerate}
\item
$z\gets lca(x,y)$
\item
$D_{z}[i]=$
\item
Aggiorna $C_{z}$
\end{enumerate}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Allineamento di 2 sequenze}
\begin{block}{Allineamento}
\begin{itemize}
\item
Input: 2 sequenze $s_{1}$ e $s_{2}$
\item
Aggiunta di \alert{indel} in $s_{1}$ e $s_{2}$
\item
sequenze estese = stessa lunghezza
\item
NO colonne di indel
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Allineamento: esempio}
\begin{block}{Input}
\texttt{ABRACADABRA}\\
\texttt{BANANA}
\end{block}

\begin{block}{sequenze allineate 1}
\texttt{ABRACADABRA}\\
\texttt{-B-ANA---NA}
\end{block}
\begin{block}{sequenze allineate 2}
\texttt{ABR-AC-ADABRA}\\
\texttt{---B-ANA---NA}
\end{block}
\begin{block}{sequenze allineate 3}
\texttt{ABRACADABRA}\\
\texttt{-BANA----NA}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Allineamento: costo o valore?}
\begin{block}{Problema di ottimizzazione}
\begin{itemize}
\item
Istanza: insieme infinito di casi
\item
Soluzioni ammissibili: ammissibilità verificabile in tempo polinomiale
\item
Funzione obiettivo: Istanza $\mapsto \mathbb{R}^{+}$
\item
Massimizzazione o minimizzazione
\end{itemize}
\end{block}
\begin{block}{costo o valore?}
\begin{itemize}
\item
Costo da minimizzare
\item
Valore da massimizzare
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Valore}
\begin{block}{Valore di un allineamento}
\begin{itemize}[<+->]
\item
Somma dei valori delle singole colonne
\item
Valore di una colonna =
\item
valore in ingresso
\end{itemize}
\end{block}

\only<4->{\begin{block}{Istanza}
\begin{itemize}
\item
due sequenze $s_{1}$ e $s_{2}$
\item
matrice di score
$d:\left(\Sigma\cup\{-\}\right)\times\left(\Sigma\cup\{-\}\right) \mapsto
\mathbb{R^{+}}$
\item
problema di massimizzazione = massima omologia
\end{itemize}
\end{block}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Needleman-Wunsch: Equazione di ricorrenza}
\begin{block}{Definizione}
$M[i,j] = $ ottimo su $s_{1}[:i]$, $s_{2}[:j]$
\end{block}
\begin{equation*}
M[i,j] = \max \left\{
\begin{array}{r}%{r@{\quad }l}
M[i-1, j-1] + d(s_{1}[i], s_{2}[j])\\
M[i  , j-1] + d( -     , s_{2}[j])\\
M[i-1, j  ] + d(s_{1}[i], -      )
\end{array}
\right.
\end{equation*}
\begin{block}{Condizione al contorno}
\begin{itemize}
\item
$M[0,0] = 0$
\item
$M[i,0] = M[i-1,0] + d(s_{1}[i],-)$
\item
$M[0,j] = M[0,j-1 + d(-,s_{2}[j])$
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Allineamento locale}
\begin{block}{Allineamento globale}
Si allineano le sequenze intere
\end{block}
\begin{block}{Allineamento locale}
\begin{enumerate}
\item
Input: $s_{1}$, $s_{2}$, matrice di score $d$
\item
Individuare sottostringhe $t_{1}$ di $s_{1}$ e $t_{2}$ di $s_{2}$ tale che
\item
$All[t_{1}, t_{2}] \geq All[u_{1}, u_{2}]$ per ogni coppia di sottostringhe
$u_{1}, u_{2}$ di $s_{1}, s_{2}$.
\item
Algoritmo banale:
calcolo tutte le sottostringhe di $s_{1}$, $s_{2}$ e ne
calcolo allineamento globale
\item
Tempo $O(n^{3}m^{3})$
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Smith-Waterman}
\begin{block}{Osservazione 1}
\begin{enumerate}
\item
Matrice $M[i,j]$ memorizza allineamento di tutte le coppie di \alert{prefissi} di
$s_{1}$, $s_{2}$
\item
Allineamento massimo fra coppie di prefissi = valore massimo in $M$
\end{enumerate}
\end{block}
\begin{block}{Osservazione 2}
\begin{enumerate}
\item
$M[0,0] = 0$
\item
quindi non si prendono sottostringhe con allineamento negativo
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Equazione di ricorrenza}
\begin{block}{Definizione}
$M[i,j] = $ ottimo fra tutte le stringhe $s_{1}[k:i]$, $s_{2}[h:j]$
\end{block}
\begin{equation*}
M[i,j] = \max \left\{
\begin{array}{r}%{r@{\quad }l}
M[i-1, j-1] + d(s_{1}[i], s_{2}[j])\\
M[i  , j-1] + d( -     , s_{2}[j])\\
M[i-1, j  ] + d(s_{1}[i], -      )\\
0
\end{array}
\right.
\end{equation*}
\begin{block}{Condizione al contorno}
\begin{itemize}
\item
$M[0,0] = M[i,0] = M[0,j] =0$
\item
punto finale = valore massimo
\item
si risale nell'allineamento fino a uno $0$.
\item
Tempo $(nm)$
\end{itemize}
\end{block}
\end{frame}



\begin{frame}[fragile]
\frametitle{Gap}
\begin{block}{Definizione}
\begin{enumerate}
\item
Sequenza contigua di indel in un \alert{allineamento}
\end{enumerate}
\end{block}
\begin{block}{Esempio}
\texttt{ABR\alert{-}AC\alert{-}ADABRA}: 2 gap\\
\texttt{\alert{---}B\alert{-}ANA\alert{---}NA}: 3 gap
\end{block}
\begin{block}{Osservazione}
\begin{enumerate}
\item
Un gap sposta il frame di lettura
\item
1 indel $\approx$ 2 indel
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Allineamento con gap generici}
\begin{itemize}[<+->]
\item
costo gap lungo $l$: $P(l)$
\item
Come descrivo l'allineamento ottimo?
\item
Come è fatta l'ultima colonna?
\item
Come è fatto l'ultimo gap?
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Gap generico}
\begin{block}{Definizione}
$M[i,j] = $ ottimo su $s_{1}[:i]$, $s_{2}[:j]$
\end{block}
\begin{equation*}
M[i,j] = \max \left\{
\begin{array}{r}%{r@{\quad }l}
M[i-1, j-1] + d(s_{1}[i], s_{2}[j])\only<2>{\alert{\text{ no gap}}}\\
\max_{l>0} M[i  , j-l] + P(l)\only<2>{\alert{\text{ gap in }s_{1}}}\\
\max_{l>0} M[i-l, j  ] + P(l)\only<2>{\alert{\text{ gap in }s_{2}}}
\end{array}
\right.
\end{equation*}
\begin{block}{Condizione al contorno}
\begin{itemize}[<+->]
\item
$M[0,0] = 0$
\item
$M[i,0] = P(i)$, $M[0,j] = P(j)$
\item
Tempo $O(nm(n+m))$
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Allineamento con gap affine}
\begin{itemize}[<+->]
\item
costo gap lungo $l$: $P_{o} + lP_{e}$
\item
$P_{o}$: costo apertura gap
\item
$P_{e}$: costo estensione gap
\item
$P_{e}, P_{o}>0$
\item
Come descrivo l'allineamento ottimo?
\item
Come è fatta l'ultima colonna?
\item
Come è fatto l'ultimo gap?
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Gap affine}
\begin{block}{Definizione}
\begin{itemize}
\item
$M[i,j] = $ ottimo su $s_{1}[:i]$, $s_{2}[:j]$
\item
$E_{1}[i,j] = $ ottimo su $s_{1}[:i]$, $s_{2}[:j]$, con estensione di gap finale
in $s_{1}$
\item
$E_{2}[i,j] = $ ottimo su $s_{1}[:i]$, $s_{2}[:j]$, con estensione di gap finale
in $s_{2}$
\item
$N_{1}[i,j] = $ ottimo su $s_{1}[:i]$, $s_{2}[:j]$, con apertura di gap alla
fine di $s_{1}$
\item
$N_{2}[i,j] = $ ottimo su $s_{1}[:i]$, $s_{2}[:j]$, con apertura di gap alla
fine di $s_{1}$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Gap affine}
\begin{equation*}
M[i,j] = \max \left\{
\begin{array}{l}%{r@{\quad }l}
M[i-1, j-1] + d(s_{1}[i], s_{2}[j])\\
E_{1}[i,j],
E_{2}[i,j] \\
N_{1}[i,j],
N_{2}[i,j]
\end{array}
\right.
\end{equation*}
\begin{equation*}
E_{1}[i,j] = \max \left\{
\begin{array}{l}%{r@{\quad }l}
E_{1}[i,j-1] + P_{e}\\
N_{1}[i,j-1] + P_{e}
\end{array}
\right.
\end{equation*}
\begin{equation*}
E_{2}[i,j] = \max \left\{
\begin{array}{l}%{r@{\quad }l}
E_{2}[i-1,j] + P_{e} \\
N_{2}[i-1,j] + P_{e}
\end{array}
\right.
\end{equation*}
\begin{equation*}
N_{1}[i,j] = M[i,j-1] + P_{o} + P_{e}, \quad
N_{2}[i,j] = M[i-1,j] + P_{o} + P_{e}
\end{equation*}
\end{frame}

\begin{frame}[fragile]
\frametitle{Allineamento multiplo}
\begin{block}{$k$ sequenze}
\begin{itemize}[<+->]
\item
Input: insieme di sequenze $\{s_{1}, \ldots , s_{k}\}$
\item
Aggiunta di \alert{indel} nelle sequenze
\item
sequenze estese = tutte stessa lunghezza
\item
NO colonne di indel
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Valore di una colonna}
\begin{block}{SP: sum of pairs}
\begin{itemize}[<+->]
\item
$\{s_{1}, \ldots , s_{k}\} \mapsto \{s^{*}_{1}, \ldots , s^{*}_{k}\}$ allineate
\item
Valore $\{s^{*}_{1}[h], \ldots , s^{*}_{k}[h]\}$
\item
$\sum_{i<j} d(s^{*}_{1}[i], s^{*}_{k}[j])$
\end{itemize}
\end{block}
\begin{block}{Complessità}
\begin{itemize}[<+->]
\item
se $k$ è arbitrario $\Rightarrow$ NP-completo
\item
se $k$ è fissato $\Rightarrow$ tempo $O(n^{k})$
\end{itemize}
\end{block}
\end{frame}


\begin{comment}
\begin{frame}[fragile]
\frametitle{Allineamento con banda.}
\begin{enumerate}
\item
$Opt$ = valore allineamento
\end{frame}
\end{frame}

\begin{comment}
\begin{frame}[fragile]
\frametitle{Algoritmo di Carrillo-Lipman}
\begin{quote}{Euristica}
\begin{enumerate}
\item
Input: $3$ sequenze $s_{1}$, $s_{2}$, $s_{3}$
\item
Non visitiamo tutta la matrice di programmazione dinamica
\item
Caso peggiore $O(n^{3})$
\end{enumerate}
\end{quote}
\end{frame}
\end{comment}

\begin{frame}[fragile]
\frametitle{Matrici di sostituzione}
\begin{enumerate}
\item
Utilizzate per valutare un allineamento
\item
Implicitamente probabilità di transizione
\item
Mutazioni ricorrenti
\item
Allineamenti di proteine
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
\frametitle{PAM: unità di misura}
\begin{enumerate}
\item
PAM: point/percent accepted mutation
\item
due sequenze $s_{1}$ e $s_{2}$: quanto sono distanti?
\item
distanza 1PAM $\Rightarrow$ numero mutazioni = $\frac{1}{100} |s_{1}|$
\item
semplice in assenza di indel
\item
Mutazioni ricorrenti $\Rightarrow$ misura affidabile solo per piccoli valori
\item
$s_{1}$ e $s_{2}$ distanti $100$ PAM $\Rightarrow$ una singola base ha 36\% di
probabilità di non essere mutata
\end{enumerate}
\end{frame}

\begin{frame}[fragile]
\frametitle{Matrici PAM}
\begin{enumerate}
\item
dipende dalla distanza attesa
\item
PAM250, PAM200, PAM1
\end{enumerate}
\begin{block}{Calcolo PAM$k$}
\begin{enumerate}
\item
Costruzione PAM$k$
\item
Si prendono varie sequenze distanti $k$PAM
\item
si allineano le sequenze
\item
si calcolano le frequenze $f(i)$, $f(i,j)$ di tutti i singoli caratteri e le
coppie di caratteri
\item
PAM$k(i,j)=\log\frac{f(i,j)}{f(i)f(j)}$
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Log odds ratio}
\begin{block}{Odds ratio}
\begin{enumerate}
\item
$\frac{p}{1-p}$, $p$ è la probabilità dell'evento interessante (target)
\item
$\frac{f(i,j)}{f(i)f(j)}$
\item
$f(i,j)$: frequenza della mutazione misurata
\item
$f(i)f(j)$: ipotesi nulla (caratteri indipendenti)
\end{enumerate}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Matrici PAM}
\begin{block}{Calcolo PAM$k$ nella realtà}
\begin{itemize}
\item
Problema: come allineare se non si conosce la matrice
\item
Allineate sequenze molto simili
\item
no indel
\item
$M_{k}(i,j)=\log\frac{f(i)M_{1}^{k}(i,j)}{f(i)f(j)}=\log\frac{M_{1}^{k}(i,j)}{f(j)}$
\item
valori moltiplicati per $10$
\item
arrotondati all'intero più vicino
\item
si somma un intero a tutti i valori
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Matrici BLOSUM}
\begin{block}{Confronto con PAM}
\begin{itemize}
\item
PAM allinea sequenze vicine
\item
ma viene usata per allineare sequenze lontane
\item
regioni conservate e non conservate hanno stessa importanza
\end{itemize}
\end{block}

\begin{block}{BLOCKS}
\begin{itemize}
\item
blocchi di regioni conservate
\item
scelte ``a mano''
\item
$B(i,j)=\log\frac{f(i,j)}{f(i)f(j)}$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Matrici BLOSUM}
\begin{block}{BLOSUM$x$}
\begin{itemize}
\item
le sequenze che sono simili più di $x$\% vengono clusterizzate
\item
cluster = rimuovere tutte tranne una
\item
scopo:  evitare di sovrapesare parti sovrarappresentate nel campione
\item
BLOSUM62: più usata per gli allineamenti
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Statistiche Karlin-Altschul}
\begin{block}{Ricerca in un database}
\begin{itemize}
\item
Punteggio positivo possibile
\item
Punteggio medio negativo
\item
Simboli indipendenti e equiprobabili
\item
Sequenze infinitamente lunghe
\item
Allineamenti senza gap
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Equazione Karlin-Altschul}
\begin{equation*}
E=kmne^{-\lambda S}
\end{equation*}
\begin{itemize}
\item
$E$: numero allineamenti
\item
$k$: costante
\item
$n$: numero caratteri in database
\item
$m$: lunghezza stringa query
\item
$\lambda S$: punteggio normalizzato
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{BLAST}
\begin{block}{Basic Local Alignment Search Tool}
\begin{itemize}
\item
Ricerca seed
\item
seed = pattern matching con sottostringa di lunghezza $3$
\item
Costruzione  high-scoring segment pair (HSP)
= estensione seed
\item
Filtro seed tenuti solo HSP con  alta significatività
\item
Fusione HSP  vicine
\item
Smith-Waterman sulle regioni
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Filogenesi perfetta.}
\end{frame}


\begin{frame}
\frametitle{Evolution}

\centering
\includegraphics<1>[height=0.6\textheight]{figures/evolution-desk-720x380.jpg}

\begin{itemize}
  \item
    Change over generations
  \item Random mutations
  \end{itemize}
\end{frame}

% \begin{frame}
% \frametitle{Good Evolution}

% \centering
% \includegraphics<1>[height=0.6\textheight]{figures/selective-pressure.jpg}

% \end{frame}

\begin{frame}
\frametitle{Actual Mutation}
 
\centering
\includegraphics<1>[height=0.6\textheight]{figures/dna_strand.jpg}

\end{frame}



\begin{frame}
\frametitle{Hollywood Mutation}

\centering
\includegraphics<1>[height=0.85\textheight]{figures/spiderman-spider-bite-comic}
\end{frame}


\begin{frame}
\frametitle{Individual Evolution}

\centering
  \includegraphics[width=\linewidth]{figures/progression}
  \begin{itemize}
    \item
      Cells \alert{accumulate} mutations throughout the entire life
  % \item
  %   Accumulate mutation $\Rightarrow$ perfect phylogeny
  \end{itemize}
\end{frame}




\begin{frame}
\frametitle{Character-based evolution}

\centering
\includegraphics<1>[height=0.55\textheight]{figures/perfect-phylogeny}

\begin{block}{A possible rule}
Each character is gained \alert{exactly once} in the tree.
\end{block}
\end{frame}


\begin{frame}
  \frametitle{Perfect Phylogeny Problem}
\begin{columns} 
  \begin{column}{0.48\textwidth}
{    \scriptsize
 \begin{tabular}{l|ccccc}
        & A & J & H & L & V\\ \hline
        Scorpion& 0 & 0 & 0 & 0 & 0\\
        Lamprey& 0 & 0 & 0 & 0 & 1\\
        Tuna& 0 & 1 & 0 & 0 & 1\\
        Salamander& 0 & 1 & 0 & 1 & 1\\
        Turtle& 1 & 1 & 0 & 1 & 1\\
        Leopard& 1 & 1 & 1 & 1 & 1
 \end{tabular}
}\begin{block}{Problem}
  \begin{itemize}
    \item
  Input: a binary matrix $M$
    \item
      Output: a tree \alert{explaining} $M$, if it exists
\end{itemize}
\end{block}

\end{column}
    
    \begin{column}{0.48\textwidth}
      \centering
\includegraphics<1>[height=0.52\textheight]{figures/perfect-phylogeny}
\end{column}
\end{columns}
\begin{block}{Linear time algorithm (Gusfield, Networks 1991)}
  \begin{enumerate}
    \item
      Sort the columns by decreasing number of $1$s
    \item
      Radix sort the rows
    \item
      Build the tree
    \end{enumerate}
  \end{block}
\end{frame}




\begin{frame}
\frametitle{Losing characters}

\centering
\includegraphics<1>[height=0.65\textheight]{figures/classification-of-life-taxonomy}

\begin{block}{A possible rule}
Each character can be lost (once).
\end{block}

\end{frame}




\begin{frame}
\frametitle{Characters and States}

\begin{block}{Change of state}
  \begin{itemize} 
\item  A character $c$ is \alert{gained} $\Rightarrow$  the state of $c$ changes from $0$ to $1$
  in an edge
\item  A character $c$ is \alert{lost} $\Rightarrow$  the state of $c$ changes from $1$ to $0$
  in an edge (\alert{backmutation})
\end{itemize}
\end{block}

\begin{block}{Models of Evolution}
  Each character $c$ is gained \alert{exactly once} in the tree.
\begin{enumerate}
\item
  Perfect Phylogeny:  No backmutations
\item
  Persistent Phylogeny: Each character can be lost at most once in the tree.
\alert{$012$ model}
\item
  \alert{Dollo} parsimony: 
  Unlimited backmutations
\end{enumerate}
\end{block}
\end{frame}



\begin{frame}
\frametitle{Persistent Phylogeny}
\begin{columns} 
  \begin{column}{0.48\textwidth}
    \begin{block}{Instance}
 \begin{tabular}{c|cccccc}\scriptsize
        $M$& $c_1$ & $c_2$ & $c_3$ & $c_4$ & $c_5$ & $c_6$\\ \hline
        $s_1$ & 0 & 0 & 0 & 1 & 0 & 0\\
        $s_2$ & 0 & 0 & 1 & 1 & 1 & 1\\
        $s_3$ & 0 & 1 & 1 & 0 & 0 & 0 \\
        $s_4$ & 1 & 1 & 0 & 0 & 0 & 0 \\
        $s_5$ & 1 & 1 & 1 & 0 & 1 & 0\\
        $s_6$ & 0 & 1 & 1 & 1 & 1 & 0
 \end{tabular}
\end{block}
\begin{block}{Problem}
  \begin{itemize}
    \item
  Input: a binary matrix $M$
    \item
Output: a persistent phylogeny consistent with $M$, if it exists
\end{itemize}
\end{block}

\end{column}
    
    \begin{column}{0.48\textwidth}
      \centering
    \begin{tikzpicture}[sibling distance=25mm, scale=0.6]
    \node[circle,draw]           (00000000) {}
    child {node[rectangle,draw]     (00010000) {$s_{1}$}
      child {node[circle,draw]     (00110000) {}
        child {node[circle,draw]  (00111000) {}
          child {node[rectangle,draw]  (00111100) {$s_{2}$}
            edge from parent node[left] {$c_{6^{+}}$}
          }
          child {node[rectangle,draw]     (01111000) {$s_{6}$}
            child {node[circle,draw]     (01101000) {}
              child {node[rectangle,draw]     (11101000) {$s_{5}$}
                child {node[circle,draw]     (11100000) {}
                  child {node[rectangle,draw]     (01100000) {$s_{3}$}
                    edge from parent node[left] {$c_{1}^{-}$}
                  }
                  child {node[rectangle,draw]     (11000000) {$s_{4}$}
                    edge from parent node[right] {$c_{3}^{-}$}
                  }
                  edge from parent node[right] {$c_{5}^{-}$}
                }
                edge from parent node[right] {$c_{1}^{+}$}
              }
              edge from parent node[right] {$c_{4}^{-}$}
            }
            edge from parent node[right] {$c_{2}^{+}$}
          }
          edge from parent node[right] {$c_{5}^{+}$}
        }
        edge from parent node[right] {$c_{3}^{+}$}
      }
      edge from parent node[right] {$c_{4}^{+}$}
    };
    \end{tikzpicture}
  \end{column}
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Tumor}

\centering
  \includegraphics[width=0.8\linewidth]{figures/tumor-heterogeneous}
  \begin{itemize}
    \item 
      A \alert{tumor} is a mixture of healthy and cancer cells
    \item 
      A \alert{tumor} is a mixture of cancer clones
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Tumor Evolution}

\centering
  \includegraphics[width=\linewidth]{figures/clonal}
\begin{itemize}
\item Different clones make different fractions of the tumor 
\end{itemize}
\end{frame}


\def\mut#1#2{%
\begin{scope}[shift={#1}]
\node[thick,draw,fill=blue!70,circle, scale=3.5] (#2) {};
\end{scope}
}

\def\muta#1#2{%
\begin{scope}[shift={#1}]
\mut{(0,0)}{#2};
\draw[fill=white] (0,0) circle (.1);
\end{scope}
}

\def\mutb#1#2{%
\begin{scope}[shift={#1}]
\muta{(0,0)}{#2};
\node[fill,color=brown,star, star points=6,scale=0.75] at (45:0.3) {};
\end{scope}
}

\def\mutc#1#2{%
\begin{scope}[shift={#1}]
\muta{(0,0)}{#2};
\node[fill,color=green,regular polygon, regular polygon sides=3,scale=0.65] at (90:0.3) {};
\end{scope}
}

\def\mutd#1#2{%
\begin{scope}[shift={#1}]
\mutc{(0,0)}{#2};
\node[fill,color=red,regular polygon, regular polygon sides=4,scale=0.75] at (0:0.3) {};
\end{scope}
}

\def\mute#1#2{%
\begin{scope}[shift={#1}]
\mutd{(0,0)}{#2};
\node[draw,cross out, draw=pink, very thick,scale=.8] at (180:.3) {};
\end{scope}
}

\def\mutf#1#2{%
\begin{scope}[shift={#1}]
\mutd{(0,0)}{#2};
\node[draw,diamond,scale=0.6, fill,color=blue]  at (270:0.3) {};
\end{scope}
}

\begin{frame}
\frametitle{Tumor Evolution}

\begin{columns} 
  \begin{column}{0.48\textwidth}
\centering
\resizebox{0.95\textwidth}{!}{\begin{tikzpicture}[,>=triangle 60]
\mutf{(-5,5)}{s5};
\muta{(-5.5,7)}{s4};
\muta{(-4,9)}{s4};

\muta{(-2.4,5.8)}{s4};
\mutb{(-1.2,6.7)}{s1};
\mutb{(-3.5,7)}{s1};
\mutc{(-2,8.2)}{s3};
\mutc{(-0.2,8)}{s3};

\mutc{(-4,2)}{s1};
\mut{(-2.5,2)}{};
\mut{(0.5,3.5)}{};
\mut{(-4.5,3.5)}{};
\mutd{(0.5,1.8)}{s6};
\mute{(-3,3.5)}{s2};
\mutf{(-1.2,3)}{s5};
\mutc{(0.5,5)}{s32};

\draw[rotate=30,thick] (2,7) ellipse (2.8 and 2.1);
\node at (-4,0.5) {Sample 1};
\draw[rotate=0,thick] (-3,2.8) ellipse (2.8 and 1.8);
\node at (-2,10) {Sample 2};
\end{tikzpicture}}
\end{column}
  \begin{column}{0.48\textwidth}

\begin{itemize}
\item A \alert{sample} is a mixture of clones
\item For each sample, we have the \alert{frequency} of each mutation
\item
  frequency matrix $F$
%\item inference of tumoral phylogeny
\end{itemize}

\centering
\resizebox{0.95\textwidth}{!}{\begin{tikzpicture}[scale=0.8]
\draw[fill=white] (3,2) circle (.1);
\node[fill,color=brown,star, star points=6,scale=0.75] at (6,2) {};
\node[fill,color=green,regular polygon, regular polygon sides=3,scale=0.65] at (2,2) {};
\node[draw,cross out, draw=pink, very thick,scale=.8] at (5,2) {};
\node[draw,diamond,scale=0.6, fill,color=blue]  at (1,2) {};
\node[fill,color=red,regular polygon, regular polygon sides=4,scale=0.75] at (4,2) {};

\node at (1,1) {0.2}; \node at (2,1) {0.6}; \node at (3,1) {0.6};
\node at (4,1) {0.4}; \node at (5,1) {0.2}; \node at (6,1) {0.0};
\node at (1,0) {0.0}; \node at (2,0) {0.4}; \node at (3,0) {1.0};
\node at (4,0) {0.0}; \node at (5,0) {0.0}; \node at (6,0) {0.4};

\node at (0,1) {$S_{1}$}; \node at (0,0) {$S_{2}$};
\end{tikzpicture}}

\end{column}
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Tumor Evolution: Compute}

\begin{columns} 
  \begin{column}{0.38\textwidth}
    \begin{block}{Matrix $B$ representing tree $T$}
    \end{block}
\centering
\resizebox{0.79\textwidth}{!}{\begin{tikzpicture}[scale=0.8]
\draw[fill=white] (3,2) circle (.1);
\node[fill,color=brown,star, star points=6,scale=0.75] at (6,2) {};
\node[fill,color=green,regular polygon, regular polygon sides=3,scale=0.65] at (2,2) {};
\node[draw,cross out, draw=pink, very thick,scale=.8] at (5,2) {};
\node[draw,diamond,scale=0.6, fill,color=blue]  at (1,2) {};
\node[fill,color=red,regular polygon, regular polygon sides=4,scale=0.75] at (4,2) {};
\end{tikzpicture}}
\begin{tabular}{rrrrrr}
    0 & 0 & 1 & 0 & 0 &1  \\
  0 & 1 & 1 & 1 & 1 &0  \\
  0 & 1 & 1 & 0 & 0 &0  \\
  0 & 0 & 1 & 0 & 0 &0  \\
  1 & 1 & 1 & 1 & 0 &0  \\
\end{tabular}
    \begin{block}{Usage matrix $U$}
    \end{block}
\resizebox{0.99\textwidth}{!}{\begin{tabular}{rrrrr}
     \multicolumn{5}{c}{Species}\\
  0 & 0.2 & 0.2 & 0 & 0.2  \\
  0.4 & 0 & 0.4 & 0.2 & 0   \\
\end{tabular}}
\end{column}


  \begin{column}{0.58\textwidth}
  \resizebox{\textwidth}{!}{
  \begin{tikzpicture}[>=triangle 60]
    \mut{(3,9.5)}{N};
    \muta{(3,7)}{s4};
    \mutb{(5,0.5)}{s1};
    \mutc{(0,5)}{s3};
\mutd{(-2,2.8)}{s6};
\mute{(-3,0.5)}{s2};
\mutf{(-1,0.5)}{s5};
\mutc{(1,0.5)}{s32};
\muta{(3,0.5)}{s42};
\draw[thick,->,>=stealth] (N) to node[midway, right=5pt,circle, fill, scale=.6] (e1){} node[right=10pt]{}(s4) ;
\draw[thick,->,>=stealth] (s4) to node[near start,right=5pt,fill,color=brown,star, star points=7,scale=0.6]  {}node[right=10pt,near start]{} (s1) ;
\draw[thick,->,>=stealth] (s4) to node[near start,left=5pt,fill,color=green,regular polygon, regular polygon sides=3,scale=0.45]  {} node[left=10pt,near start]{} (s3) ;
\draw[thick,->,>=stealth] (s3) to node[near start,left=5pt,fill,color=red,regular polygon, regular polygon sides=4,scale=0.7]  {} node[left=10pt,near start]{} (s6) ;
\draw[thick,->,>=stealth] (s6) to node[near start,left=5pt,draw,cross out, pink, very thick,scale=.7]  {} node[left=10pt,near start]{} (s2) ;
\draw[thick,->,>=stealth] (s6) to node[near start,right=5pt,fill,diamond,scale=0.5, fill,color=blue]  {} node[right=10pt,near start]{} (s5) ;
\draw[thick,->,>=stealth] (s3) -- (s32) ;
\draw[thick,->,>=stealth] (s4) to   (s42) ;

\draw (-4,-1) rectangle node[pos=.18] {Sample 1}(1.9,1.5);
\draw[dashed] (6,-1.5) rectangle node[yellow, pos=.2] {Sample 2}(0.0,2);
  \end{tikzpicture}
}
\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Tumor Evolution}

\centering
\resizebox{0.4\textwidth}{!}{$F=UB$}

\vspace{1ex}
\onslide<2->{
\begin{block}{Approaches}
  \begin{itemize}
  \item
    Split-row (Hajirasouliha and Raphael, WABI, 2014).
    Guess the composition of each sample.
  \item
    AncesTree (El-Kebir, Bioinformatics, 2015).
    Guess the phylogeny, constraint on the frequencies.
  \end{itemize}
\end{block}}
\onslide<3->{
\begin{block}{Model}
 Perfect phylogeny $\Rightarrow$ infinite site assumption
\end{block}
\begin{block}{Cons}
    no mutation loss
\end{block}}
\end{frame}

\begin{frame}
\frametitle{Attack to the infinite site assumption!}

\begin{itemize}
  \item
``Our results refute the general validity of
the infinite sites assumption''
  \item
``6 childhood
acute lymphoblastic leukemia (ALL) patients \ldots
Our test returns extremely high BFs\footnote{BF: Bayes Factor.
 It is ratio of the likelihoods of seeing the
  actual data given the infinite site assumption and the finite site assumption} in the
range 
of \alert{$10^{5}$} to \alert{$10^{15}$} \ldots
for all samples apart from patient 5, the recurrent
mutation is a \alert{back mutation}''
\end{itemize}

\vspace{1ex}
From: A statistical test on single-cell data reveals widespread
recurrent mutations in tumor evolution, Kuipers et al., BioRxiv, 2016
\end{frame}

\begin{frame}
\frametitle{Back mutations for the win!}

\begin{itemize}
  \item
``infer the phylogeny for individual patients using the \alert{Dollo parsimony}
method and a branch and bound exhaustive search for the best phylogenetic
reconstruction''
  \item
``In genomically unstable cancers, \alert{deletion of
  large chromosomal segments is common}''
  \item
``large deletions on
several branches of a tree can span a shared locus, and thus a given mutation may be \alert{deleted independently multiple
times}''
\end{itemize}

\vspace{1ex}
From:
Brown, D. et al. Phylogenetic analysis of metastatic progression
in breast cancer using somatic mutations and copy number aberrations. Nat. Commun.
8, 14944 doi: 10.1038/ncomms14944 (2017)
\end{frame}

\begin{frame}
\frametitle{Tumor Evolution}

\begin{columns} 
  \begin{column}{0.4\textwidth}
\begin{block}{Approaches}
  \begin{itemize}
  \item
    Persistent Phylogeny (Bonizzoni et al., ACM BCB, 2017)
  \item
    ILP
  \item
    Also Dollo$(k)$
  \item
    choose number of clones
  \end{itemize}
\end{block}
\end{column}
  \begin{column}{0.5\textwidth}

\centering

\uncover<2->{
\resizebox{!}{17em}{
  \begin{tikzpicture}[
    sibling distance=55mm,
    level 5/.style={sibling distance=45mm},
  every node/.style = {shape=ellipse, draw, align=center},
  loss/.style = {draw=blue, fill=red, text=black, align=center}
  ]
  \node {Germline}
    child { node { SAMHD1 }
      child { node { EXOC6B }
        child {node { NAMPTL }
            child {node { SLC12A1 }
                child {node { PLA2G16 }
                    child {node { DAZAP1 }
                        child {node[loss] { NAMPTL- }
                            child {node { LRRC16A }
                                child {node { GHDC }}
                            }
                        }
                    }
                }
            }
            child {node[loss] { EXOC6B- }
                child {node { NOD1 }}
                child {node { BCL2L13 }
                    child {node { GPR158 }
                        child {node { COL24A1 }
                            child {node { HMCN1 }}
                        }
                        child {node { OCA2 }}
                    }
                }
            }
        }
      }
      child { node { MAP2K1 }
        child {node { KLHDC2 }}
      }
         };
\end{tikzpicture}
}}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Algoritmo lineare per filogenesi perfetta.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Approcci basati su distanze.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Ultrametrica e orologio molecolare.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Alberi e distanze additive.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Algoritmo per matrice di distanze additive.}
\end{frame}

\begin{frame}[fragile]
\frametitle{UPGMA.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Neighbor Joining.}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Modelli di evoluzione.}
\begin{itemize}
\item
  Probabilità di transizione fra stati (A, C, G, T).
%
\item
  dipende dal tempo trascorso fra i due eventi
\item
  tasso istantaneo di mutazione
\item
  somma su ogni riga = $0$
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Modelli di evoluzione: Jukes-Cantor.}
\begin{itemize}
\item
  ogni mutazione è equiprobabile
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Massima verosimiglianza.}
\end{frame}



\begin{frame}[fragile]
\frametitle{Sequenziamento e grafi di de Brujin}
\end{frame}



\begin{frame}[containsverbatim]\frametitle{Licenza d'uso}
  \small

  Quest'opera {\`e} soggetta alla licenza Creative Commons: Attribuzione-Condividi
  allo stesso modo 3.0.

  \verb+https://creativecommons.org/licenses/by-sa/4.0/+

  Sei libero di riprodurre, distribuire, comunicare al pubblico, esporre in
  pubblico, rappresentare, eseguire, recitare e modificare quest'opera
  alle seguenti condizioni:
  \begin{itemize}
  \item
    Attribuzione — Devi attribuire la paternit{\`a} dell'opera nei modi indicati
    dall'autore o da chi ti ha dato l'opera in licenza e in modo tale da non
    suggerire che essi avallino te o il modo in cui tu usi l'opera.
  \item
    Condividi allo stesso modo — Se alteri o trasformi quest'opera, o se la usi
    per crearne un'altra, puoi distribuire l'opera risultante solo con una licenza
    identica o equivalente a  questa.
  \end{itemize}
  \vspace*{1cm}
\end{frame}





\end{document}
%%% Local Variables:
%%% TeX-PDF-mode: t
%%% TeX-master: "lucidi_bioinformatica_video"
%%% buffer-file-coding-system: utf-8
%%% End:
